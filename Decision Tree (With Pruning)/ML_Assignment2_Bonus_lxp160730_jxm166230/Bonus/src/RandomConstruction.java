
import java.io.*;
import java.text.DecimalFormat;

public class RandomConstruction 
{
	
	private static double logCalculator(double prob) 
	{
		return Math.log10(prob) / Math.log10(2);
	}
	
	public static void main(String[] args) 
	{
		String training_data,testing_Data,validation_Data;
		training_data = args[0];
		testing_Data = args[1];
		validation_Data = args[2];
		int h=0;
		
		node initial_node=null;
		node random_rootnode=null;
		
		try{
		
		int[] training_feature_instances = fetch_Features(training_data);
		int[] testing_features_instances = fetch_Features(testing_Data);
		int[] validation_features_instances = fetch_Features(validation_Data);
		int[][] values = new int[training_feature_instances[1]][training_feature_instances[0]];
		String[] Attributes = new String[training_feature_instances[0]];
		int[] isCompleted = new int[training_feature_instances[0]];
		int[] Register = new int[values.length];
		fetch_Values(training_data, values, Attributes, isCompleted, Register,training_feature_instances[0]);
		initial_node = buildDecisionTree(null, values, isCompleted, training_feature_instances[0] - 1, Register, null,h);
		
		DecimalFormat df = new DecimalFormat("###.00");  
		
		System.out.println("*******************INITIAL TREE********************");
		display_Tree(initial_node, 0, Attributes);
		
		int noOfNodes=node.count;
		int nonLeafCount = NonLeafCount(initial_node);
		
		double initial_training_accuracy = Accuracy_Calculator(training_data,initial_node);
		double initial_test_accuracy = Accuracy_Calculator(testing_Data,initial_node);
		double initial_validation_accuracy = Accuracy_Calculator(validation_Data,initial_node);
		
		random_rootnode = build_random_DecisionTree(null, values, isCompleted, training_feature_instances[0] - 1, Register, null,h);
		System.out.println("\n");
		System.out.println("\n");
		System.out.println("*******************RANDOM TREE********************");
		display_Tree(random_rootnode, 0, Attributes);
		int randomNodes=node.count-noOfNodes;
		
		double random_training_accuracy = Accuracy_Calculator(training_data,random_rootnode);
		double random_test_accuracy = Accuracy_Calculator(testing_Data,random_rootnode);
		double random_validation_accuracy = Accuracy_Calculator(validation_Data,random_rootnode);
		
		System.out.println("\n");
		System.out.println("\n");
		System.out.println("Total number of nodes in the initial tree using ID3= "+noOfNodes);
		System.out.println("Average depth of Decision Tree using ID3:"+Math.ceil(logCalculator(noOfNodes+1)));
		System.out.println("\n");
		System.out.println("Total number of nodes in the Random tree : "+randomNodes);
		System.out.println("Average depth of random Decision Tree:"+Math.ceil(logCalculator(randomNodes+1)));
		System.out.println("\n");
		System.out.println("Accuracy of the model generated by ID3 on the training data = " + df.format(initial_training_accuracy)+"%");
		System.out.println("Accuracy of the random model on the training data = " + df.format(random_training_accuracy)+"%");
		System.out.println("\n");

		System.out.println("Accuracy of the ID3 model on the validation data = " + df.format(initial_validation_accuracy)+"%");
		System.out.println("Accuracy of the random model on the validation data = " + df.format(random_validation_accuracy)+"%");
		System.out.println("\n");
		
		System.out.println("Accuracy of the ID3 model on the testing data = " + df.format(initial_test_accuracy)+"%");
		System.out.println("Accuracy of the random model on the testing data = " + df.format(random_test_accuracy)+"%");
		System.out.println("\n");
	


	}
	catch(Exception e){
		e.printStackTrace();
	}
	}
	
    private static node ConstructTree(node initial_node, int[][] values, int[] isCompleted, int features,
			int[] Register) 
	{
		int i = 0;
		int k = 0;
		double maximum_Information_Gain = 0;
		int max_Left_Index[] = null;
		int max_Right_Index[] = null;
		int max_Index = -1;
		for (; i < features; i++) 
		{
			if (isCompleted[i] == 0) 
			{
				double negative = 0;
				double positive = 0;
				double left = 0;
				double right = 0;
				int[] leftIndex = new int[values.length];
				int[] rightIndex = new int[values.length];
				double infoGain = 0;
				double right_Positive = 0;
				double right_Negative = 0;
				double left_Positive = 0;
				double left_Negative = 0;
				double entropy = 0;
				double left_Entropy = 0;
				double right_Entropy = 0;
				
				for (k = 0; k < Register.length; k++) 
				{
					if (values[Register[k]][features] == 1) 
					{
						positive++;
					} else 
					{
						negative++;
					}
					if (values[Register[k]][i] == 1) 
					{
						rightIndex[(int) right++] = Register[k];
						if (values[Register[k]][features] == 1) 
						{
							right_Positive++;
						} else 
						{
							right_Negative++;
						}

					} else {
						leftIndex[(int) left++] = Register[k];
						if (values[Register[k]][features] == 1) 
						{
							left_Positive++;
						} else 
						{
							left_Negative++;
						}

					}

				}

				entropy = (-1 * logCalculator(positive / Register.length) * ((positive / Register.length)))
						+ (-1 * logCalculator(negative / Register.length) * (negative / Register.length));
				left_Entropy = (-1 * logCalculator(left_Positive / (left_Positive + left_Negative))
						* (left_Positive / (left_Positive + left_Negative)))
						+ (-1 * logCalculator(left_Negative / (left_Positive + left_Negative))
								* (left_Negative / (left_Positive + left_Negative)));
				right_Entropy = (-1 * logCalculator(right_Positive / (right_Positive + right_Negative))
						* (right_Positive / (right_Positive + right_Negative)))
						+ (-1 * logCalculator(right_Negative / (right_Positive + right_Negative))
								* (right_Negative / (right_Positive + right_Negative)));
				if (Double.compare(Double.NaN, entropy) == 0) 
				{
					entropy = 0;
				}
				if (Double.compare(Double.NaN, left_Entropy) == 0) 
				{
					left_Entropy = 0;
				}
				if (Double.compare(Double.NaN, right_Entropy) == 0) 
				{
					right_Entropy = 0;
				}

				infoGain = entropy
						- ((left / (left + right) * left_Entropy) + (right / (left + right) * right_Entropy));
				if (infoGain >= maximum_Information_Gain) 
				{
					maximum_Information_Gain = infoGain;
					max_Index = i;
					int left_Temp_Array[] = new int[(int) left];
					for (int index = 0; index < left; index++) 
					{
						left_Temp_Array[index] = leftIndex[index];
					}
					int right_Temp_Array[] = new int[(int) right];
					for (int index = 0; index < right; index++) 
					{
						right_Temp_Array[index] = rightIndex[index];
					}
					max_Left_Index = left_Temp_Array;
					max_Right_Index = right_Temp_Array;

				}
			}
		}
		initial_node.target_Attribute = max_Index;
		initial_node.left_Indices = max_Left_Index;
		initial_node.right_Indices = max_Right_Index;
		return initial_node;
	}

	
	public static boolean Check_Positive(int[] Register, int[][] instances, int features) 
	{
		boolean state = true;
		for (int i : Register) 
		{
			if (instances[i][features] == 0)
				state = false;
		}
		return state;

	}

	public static boolean Check_Negative(int[] Register, int[][] instances, int features) 
	
	{
		boolean state = true;
		for (int i : Register) 
		{
			if (instances[i][features] == 1)
				state = false;
		}
		return state;

	}

	
	public static int Maximum_Value(node initial_node, int[][] instances, int features) 
	{
		int One = 0;
		int Zero = 0;
		if (initial_node.parent == null) 
		{
			int i = 0;
			for (i = 0; i < instances.length; i++) 
			{
				if (instances[i][features] == 1) 
				{
					One++;
				} 
				else 
				{
					Zero++;
				}
			}
		} 
		else 
		{
			for (int i : initial_node.parent.left_Indices) 
			{
				if (instances[i][features] == 1) 
				{
					One++;
				} 
				else 
				{
					Zero++;
				}
			}

			for (int i : initial_node.parent.right_Indices) 
			{
				if (instances[i][features] == 1) 
				{
					One++;
				} 
				else 
				{
					Zero++;
				}
			}
		}
		if(Zero > One)
			return 0;
		else
			return 1;

	}

	
	public static boolean ProcessedAllAttributes(int[] isCompleted) 
	{
		boolean Complete = true;
		for (int i : isCompleted) 
		{
			if (i == 0)
				Complete = false;
		}
		return Complete;
	}

	public static node buildDecisionTree(node initial_node, int[][] values, int[] isCompleted, int features, int[] Register, node parent, int h) 
	{
		if (initial_node == null) 
		{
			initial_node = new node();
			if (Register == null || Register.length == 0) 
			{
				initial_node.addr = Maximum_Value(initial_node, values, features);
				initial_node.is_Leaf = true;
				return initial_node;
			}
			if (Check_Positive(Register, values, features)) 
			{
				initial_node.addr = 1;
				initial_node.is_Leaf = true;
				return initial_node;
			}
			if (Check_Negative(Register, values, features)) 
			{
				initial_node.addr = 0;
				initial_node.is_Leaf = true;
				return initial_node;
			}
			if (features == 1 || ProcessedAllAttributes(isCompleted)) 
			{
				initial_node.addr = Maximum_Value(initial_node, values, features);
				initial_node.is_Leaf = true;
				return initial_node;
			}
		}
		initial_node = ConstructTree(initial_node, values, isCompleted, features, Register);
		initial_node.parent = parent; 
		if (initial_node.target_Attribute != -1)
			isCompleted[initial_node.target_Attribute] = 1;
		int left_Is_Complete[] = new int[isCompleted.length];
		int right_Is_Complete[] = new int[isCompleted.length];
		for (int j = 0; j < isCompleted.length; j++) {
			left_Is_Complete[j] = isCompleted[j];
			right_Is_Complete[j] = isCompleted[j]; 

		}

		initial_node.left = buildDecisionTree(initial_node.left, values, left_Is_Complete,features, initial_node.left_Indices, initial_node,h);
		initial_node.right = buildDecisionTree(initial_node.right, values, right_Is_Complete,features,initial_node.right_Indices, initial_node,h);
		return initial_node;
	}

	
	public static node create_Duplicate(node initial_node) 
	{
		if (initial_node == null)
			return initial_node;

		node temporary = new node();
		temporary.addr = initial_node.addr;
		temporary.is_Leaf = initial_node.is_Leaf;
		temporary.left_Indices = initial_node.left_Indices;
		temporary.right_Indices = initial_node.right_Indices;
		temporary.target_Attribute = initial_node.target_Attribute;
		temporary.parent = initial_node.parent;
		temporary.left = create_Duplicate(initial_node.left); 
		temporary.right = create_Duplicate(initial_node.right); 
		return temporary;
	}
	
	



	
	private static int is_Rightly_Classified(int[] setValues, node new_Node) {
		int index = new_Node.target_Attribute;
		int rightly_Classified = 0;
		node testing_Node = new_Node;
		while (testing_Node.addr ==-1) {
			
			if (index>=0&&setValues[index] == 1) {
				testing_Node = testing_Node.right;
			} else {
				testing_Node = testing_Node.left;
			}
			if (testing_Node.addr == 1 || testing_Node.addr == 0) {
				if (setValues[setValues.length - 1] == testing_Node.addr) {
					rightly_Classified = 1;
					break;
				} else {
					break;
				}
			}
			index = testing_Node.target_Attribute;
		}
		return rightly_Classified;
	}

	
	
	private static int NonLeafCount(node initial_node) {
		if (initial_node == null || initial_node.is_Leaf)
			return 0;
		else
			return (1 + NonLeafCount(initial_node.left) + NonLeafCount(initial_node.right));
	}
		


	private static int[] fetch_Features(String file) 
	{
		BufferedReader br = null;
		int c = 0;
		int[] training_feature_instances = new int[2];
		String line = "";
		try 
		{

			br = new BufferedReader(new FileReader(file));
			while ((line = br.readLine()) != null) 
			{
				if (c == 0) 
				{
					String[] features = line.split(",");
					training_feature_instances[0] = features.length;
				}
				c++;
			}

		} 
		catch (Exception e) 
		{
			e.printStackTrace();
		} 
		finally 
		{
			if (br != null) 
			{
				try 
				{
					br.close();
				} 
				catch (Exception e) 
				{
					e.printStackTrace();
				}
			}
		}
		training_feature_instances[1] = c;
		return training_feature_instances;
	}

	
	private static void fetch_Values(String file, int[][] instances, String[] Attributes, int[] isCompleted,int[] Register, int features) 
	{
		BufferedReader br = null;
		String line = "";
		for (int k = 0; k < features; k++) {
			isCompleted[k] = 0;
		}
		int k = 0;
		for (k = 0; k < instances.length; k++) {
			Register[k] = k;
		}
		try {

			br = new BufferedReader(new FileReader(file));
			int c = 0;
			while ((line = br.readLine()) != null) 
			{
				String[] attr = line.split(",");
				int i = 0;
				if (c == 0) 
				{
					for (String att : attr) 
					{
						Attributes[i] = att;
						i++;
					}
				}

				else 
				{

					for (String att : attr) 
					{
						String[] attr1 = att.split(",");
						for( String attr2 : attr1) {
						instances[c][i++] = Integer.parseInt(attr2);
						}
					}
				}
				c++;
			}
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
		}
		finally 
		{
			if (br != null) 
			{
				try 
				{
					br.close();
				} 
				catch (Exception e) 
				{
					e.printStackTrace();
				}
			}
		}
	}

	
	private static void display_Tree(node initial_node, int display_Lines, String[] Attributes) 
	{
		int i = display_Lines;
		if (initial_node.is_Leaf) 
		{
			System.out.println(" " + initial_node.addr);
			return;
		}
		for (int j = 0; j < i; j++) 
		{
			System.out.print("| ");
		}
		if (initial_node.left != null && initial_node.left.is_Leaf && initial_node.target_Attribute !=-1)
			System.out.print(Attributes[initial_node.target_Attribute] + "= 0 :");
		else
			if(initial_node.target_Attribute !=-1)
			System.out.println(Attributes[initial_node.target_Attribute] + "= 0 :");

		display_Lines++;
		display_Tree(initial_node.left, display_Lines, Attributes);
		for (int j = 0; j < i; j++) 
		{
			System.out.print("| ");
		}
		if (initial_node.right != null && initial_node.right.is_Leaf&& initial_node.target_Attribute !=-1)
			System.out.print(Attributes[initial_node.target_Attribute] + "= 1 :");
		else
			if(initial_node.target_Attribute !=-1)
			System.out.println(Attributes[initial_node.target_Attribute] + "= 1 :");
		display_Tree(initial_node.right, display_Lines, Attributes);
	}

	
	private static double Accuracy_Calculator(String file, node initial_node) 
	{
		double accuracy = 0;
		int[][] testing_data = fetch_testing_data(file);
		
		
		for (int i = 0; i < testing_data.length; i++) {
			
			accuracy += is_Rightly_Classified(testing_data[i], initial_node);
			
		}
		return (accuracy / testing_data.length)*100;

	}

	
	private static int[][] fetch_testing_data(String file) 
	{
		int[] training_feature_instances = fetch_Features(file);
		int[][] validation_set = new int[training_feature_instances[1]][training_feature_instances[0]];
		BufferedReader br = null;
		String line = "";
		try {

			br = new BufferedReader(new FileReader(file));
			int i = 0;
			int c = 0;
			while ((line = br.readLine()) != null) 
			{
				String[] attr = line.split(",");
				int j = 0;
				if (c == 0) 
				{
					c++;
					continue;
				}

				else 
				{

					for (String att : attr) 
					{
						validation_set[i][j++] = Integer.parseInt(att);
					}
				}
				i++;
			}
		} 
		catch (Exception e) 
		{
			e.printStackTrace();
		} 
		finally 
		{
			if (br != null) 
			{
				try 
				{
					br.close();
				} 
				catch (Exception e) 
				{
					e.printStackTrace();
				}
			}
		}
		return validation_set;
	}
	

public static node build_random_DecisionTree(node initial_node, int[][] values, int[] isCompleted, int features, int[] Register, node parent, int h) 
{
	if (initial_node == null) 
	{
		initial_node = new node();
		if (Register == null || Register.length == 0) 
		{
			initial_node.addr = Maximum_Value(initial_node, values, features);
			initial_node.is_Leaf = true;
			return initial_node;
		}
		if (Check_Positive(Register, values, features)) 
		{
			initial_node.addr = 1;
			initial_node.is_Leaf = true;
			return initial_node;
		}
		if (Check_Negative(Register, values, features)) 
		{
			initial_node.addr = 0;
			initial_node.is_Leaf = true;
			return initial_node;
		}
		if (features == 1 || ProcessedAllAttributes(isCompleted)) 
		{
			initial_node.addr = Maximum_Value(initial_node, values, features);
			initial_node.is_Leaf = true;
			return initial_node;
		}
	}
	initial_node = Construct_Random_Tree(initial_node, values, isCompleted, features, Register);
	initial_node.parent = parent; 
	if (initial_node.target_Attribute != -1)
		isCompleted[initial_node.target_Attribute] = 1;
	int left_Is_Complete[] = new int[isCompleted.length];
	int right_Is_Complete[] = new int[isCompleted.length];
	for (int j = 0; j < isCompleted.length; j++) {
		left_Is_Complete[j] = isCompleted[j];
		right_Is_Complete[j] = isCompleted[j]; 

	}

	initial_node.left = build_random_DecisionTree(initial_node.left, values, left_Is_Complete,features, initial_node.left_Indices, initial_node,h);
	initial_node.right = build_random_DecisionTree(initial_node.right, values, right_Is_Complete,features,initial_node.right_Indices, initial_node,h);
	return initial_node;
}

private static node Construct_Random_Tree(node initial_node, int[][] values, int[] isCompleted, int features,
		int[] Register) 
{

	int i = (int) (Math.random()*features);
	int k = 0;
	int max_Left_Index[] = null;
	int max_Right_Index[] = null;

		if (isCompleted[i] == 0) 
		{
			int left = 0;
			int right = 0;
			int[] leftIndex = new int[values.length];
			int[] rightIndex = new int[values.length];
			
			for (k = 0; k < Register.length; k++) 
			{
				
				if (values[Register[k]][i] == 1) 
				{
					rightIndex[right++] = Register[k];
					
				} else {
					leftIndex[left++] = Register[k];
					
				}

			}
				int left_Temp_Array[] = new int[(int) left];
				for (int index = 0; index < left; index++) 
				{
					left_Temp_Array[index] = leftIndex[index];
				}
				int right_Temp_Array[] = new int[(int) right];
				for (int index = 0; index < right; index++) 
				{
					right_Temp_Array[index] = rightIndex[index];
				}
				max_Left_Index = left_Temp_Array;
				max_Right_Index = right_Temp_Array;

			}
	initial_node.target_Attribute = i;
	initial_node.left_Indices = max_Left_Index;
	initial_node.right_Indices = max_Right_Index;
	return initial_node;
}
}


 class node 
{
	public static int count; 
	public node(){
		super();
		count++;
	}
	node parent;
	node left;
	node right;
	int addr = -1;
	boolean is_Leaf = false; 
	int target_Attribute = -1;
	int left_Indices[];
	int right_Indices[];
	
}